---
title: "R qPCR Template"
author: "David Colameo"
date: "13 10 2021"
output: html_document
editor_options: 
  chunk_output_type: console
---



# How To Load Data into R

There are numerous ways of how to import datasets into R. You can prepare them in Excel and save them either as excel-files or csv-files.
Other types of files are often also supported (txt, SQL-databases)

Prepare your data into a nice format in excel and keep it simple. It is important to not put more than one table per sheet. There is no need to make manual adjustments on excel, since those are much easier to implement in R and take more often than not just one line of code.

Lets start with a dummy qPCR-dataset, where the wells are labelled using the Plate-setup from the BioRad-program and then the results exported as excel-files

```{r}

##First lets import some packages, its good practice to import all needed packages at the beginning of the RMarkdown. So you can continuously add packages in this section as you write more and more code.

library(readxl)

## You should know where you saved your excel-file. I like to create a folder per markdown and save all related files in the same folder. You can find your file easier, you can use R-Studio auto-complete functionality by first writing "./" and then tab (|->) key on your keyboard.

getwd()
excelPath <- "./TaqMan_Cq_Data.xlsx"
data <- read_excel(excelPath)

##Lets convert the data-object into a data.frame-object
data <- as.data.frame(data)


##There is a lot of "junk" in the table, since I didnt modify it manually on excel and took it as it was exported from the BioRad-program
## Lets clean it up a bit and select only the relevant columns and omit rows that are not complete (with NAs) because of empty wells

cols <- c("Target", "Sample", "Biological Set Name", "Cq")
data <- data[,cols]
data <- data[complete.cases(data),]
#Lets have a look
head(data)

```


# Table manipulations

Now that we have a clean table, we can start to modify it and add information to the table. For example, the triplicates are all stacked upon each other, we want to have them all in a row with columns like replicate1, replicate2, replicate3. Also RH stands for right hemisphere, LH stands for left hemispehere. I know that we injected into the RH always an LNA and a negative control (NC) into the left hemisphere except for Mouse 35. Another information to add is, M33 to M36 are injected with LNA218, M37 to M40 are injected with LNA129. These kind of manipulations heavily depends on how you organize your labelling of experiments and it is something you might need to change from analysis to analysis. Ofc if you find a system that works for you, try to keep it that way all the time to build a routine.


### Lets add triplicates
This section can be reused easily all the time

```{r}

library(reshape2)

#Here we are creating a column with unique names except for the triplicates. 
data$Group <- paste(data$Target, data$Sample, data$`Biological Set Name`, sep=".")

unique(data$Group)

##Lets add a new column Rep (for replicate) and then we will add in here whether a row is replicate 1, 2 or 3
data$Rep = NA
for(g in unique(data$Group)){
  
  data[data$Group == g,]$Rep <- paste("Rep", rep(1:nrow(data[data$Group == g,])), sep="")
  
}

#lets check
head(data)

#Now lets transform our data from long format to wide format
data <- dcast(data, Target + Sample + `Biological Set Name` ~ Rep, value.var = "Cq")

head(data)

##VoilÃ , looks much nicer now. You will notice how we have also a Rep5-6. This is the case, because during the pipetting of the qPCR I thought I did a pipetting error in one of the conditions, I added 3 more replicates for that condition

data[complete.cases(data),]
rowMeans(data[complete.cases(data),4:6])
rowMeans(data[complete.cases(data),7:9])
rowMeans(data[complete.cases(data),4:9])
t.test(data[complete.cases(data),4:6], data[complete.cases(data),7:9])

## Since it looks like the values of the 6 replicates are all very similar, we can do a mean of all 6 replicates

##Now lets add a column meanCq with the means of all 3 replicates
data$meanCq <- rowMeans(data[,4:9], na.rm = T)
head(data)


```



## House-Keeping Gene

Now lets add the values of the house-keeping gene. In this case it is U6. For that, we will split our data-table into two, one part with the genes of interest and the other half with the U6-values. Then we will merge those two tables back together column-wise (in the wide format). For splitting tables, subset is a useful-function

```{r}

##All genes except U6
data.targets <- subset(data, Target != "U6")
##Only U6
data.u6 <- subset(data, Target == "U6")

#lets merge those two tables according to Sample and Biological Set Name Column
data <- merge(data.targets,data.u6 , suffixes = c(".tar", ".u6"), by=c("Sample", "Biological Set Name"))



## Lets perform the delta Cq normalisation; which is subtracting meanCq of the targets from the meanCq of U6. This is equivalent to performing a division since we are in the log2-scale (2^Cq1 / 2^Cq2 -> Cq1 - Cq2 -> 2^(Cq1-Cq2))

data$dCq <- data$meanCq.tar - data$meanCq.u6


# You can also add the fold-change if you want

data$Fold.dCq <- 2^ -(data$dCq)
head(data)
```



### Lets add experiment-specific additional information

```{r}
## ifelse is a useful tool to add such information very efficiently. You can give a statement to the function and it will add a value to a new column if it is true or add another value if it isnt. This is equivalent as for-looping over every row and ask the question but much more efficient and faster.


## if LH -> NC otherwise LNA
data$LNA <- ifelse(data$`Biological Set Name` == "LH", "NC", "LNA")

## First group of mice
m1 <- c("M33", "M34", "M35", "M36")

## If these mice belong to this group AND the hemisphere is right, lets add LNA218, otherwise the previous value (otherwise you will overwrite the NC you added before)
data$LNA <- ifelse(data$Sample %in% m1 & data$`Biological Set Name` == "RH", "LNA218", data$LNA )

## Same here with LNA129
m2 <- c("M37", "M38", "M39", "M40")
```


```{r}
data$LNA <- ifelse(data$Sample %in% m2 & data$`Biological Set Name` == "RH", "LNA129", data$LNA )

## Lets add a column to group the mice in either LNA218 or LNA129 injected mice
data$Coort <- ifelse(data$Sample %in% m1, "Coort1 (LNA218)", "Coort2 (LNA129)")

##Lets change the values for that one mouse that was injected differently
data$LNA <- ifelse(data$Sample =="M35" & data$`Biological Set Name` == "RH", "NC", data$LNA)
data$LNA <- ifelse(data$Sample =="M35" & data$`Biological Set Name` == "LH", "LNA218", data$LNA)

head(data)

```


## Plots the Data

There is a separate in-depth tutorial on how to plot data properly. Using those templates we can create following plot. We have the measured miRNA (miR129 or miR218 in the X-axis and -dCq in the y-axis (normalized to U6)) We can furhter divide the plot in two using the Coort-column as factor in facet_grid. Plus, we need a boxplot for the right and left hemisphere (LNA vs Negative Control Injection) which we can achieve using the grouping-aesthetic. 

```{r}
library(ggplot2)

p <- ggplot(data, aes(x=Target.tar, y=-dCq, color=Sample, fill=LNA, group= interaction(LNA, Target.tar)))  + 
  geom_boxplot(alpha=0.3, aes(fill=LNA))+
  
  geom_point(aes(color=Sample), alpha=0.8, position = position_dodge(0.75), size=3) + facet_grid(.~Coort, scales="free")

  
  # ##adding dots here
  # geom_dotplot(aes(fill=Sample, color=Sample), binaxis='y', stackdir='center', binwidth=1/7,  position = position_dodge(0.75)) + facet_grid(.~Coort, scales="free")


p


```

## Statistics
There will be a whole section about statistics. For this kind of analysis, we will employ an ANOVA using the mouse-factor as blocking, so we can compare the effect of the LNA within a subject (mouse). Afterwards, we will perform a post-hoc analysis using the emmeans-package. We can also compare the data if we tranform it to the fold-change to see if we get the same results

```{r}
library(emmeans)


mod <- aov(-dCq ~ LNA*Target.tar + Sample, data)
summary(mod)

##There is no effect of the sample, which is good. There is no obvious mouse-outlier. Plus, we have an effect for the target (meaning that miR129 and miR218 levels are different) and there is an effect of LNA (LNA does something). Also, there is an interaction between targets and LNA, meaning the LNAs have specific effects (LNA218 vs LNA129)


##Now the contrasts, LNA-effect within a target (made possible by | command)
emmeans(mod, pairwise ~ LNA | Target.tar)

## We only see differences, if we manipulate the miRNA we are measuring.

##We can also build two separate models, one per coort



mod <- aov(-dCq ~ LNA*Target.tar, subset(data, Coort== "Coort1 (LNA218)"))
summary(mod)


emmeans(mod, pairwise ~ LNA | Target.tar)



mod <- aov(-dCq ~ LNA*Target.tar, subset(data, Coort== "Coort2 (LNA129)"))
summary(mod)

emmeans(mod, pairwise ~ LNA | Target.tar)




```



## Classical ddCq Approach

What if we want to perform a classical ddCQ analysis. Again, a ddCq is nothing else than a division in the log-transform scale, meaning we need to subtract a condition by a control. In our case, we first normalized to a house-keeping gene and now we add a second layer of normalization, which is the LNA-effect vs negative control. Again, we can split the data into two and then re-merge them:



```{r}

## %in% is used if we have a condition with more than one matching condition (instead of concatenating twice the same statement)
lna <- subset(data, LNA %in% c("LNA218", "LNA129"))
ctrl <- subset(data, LNA == "NC")

## We will merge the two tables according to mouse and coort, which will make sure that we are pairing the right negative controls with the right condition

ddCq.data <- merge(lna, ctrl, suffixes = c(".lna", ".ctrl"), by=c("Sample", "Coort", "Target.tar"))

head(ddCq.data)

## Now we have a rather wide data.frame. At this point we could also clip the data a bit and omit useless columns. Or we keep just going. We just need to add a normalized ddCq column

ddCq.data$ddCq <- ddCq.data$dCq.lna - ddCq.data$dCq.ctrl
ddCq.data$fold.ddCq <- 2^- ddCq.data$ddCq


```




## Lets Plot the ddCq and Fold-change

We will add a dashed line at the intercept for 0 and 1, respectively, indicating no change.

```{r}

p <- ggplot(ddCq.data, aes(x=Target.tar, y=-ddCq, group= Target.tar))  + 
geom_boxplot(alpha=0.4, aes(fill=Target.tar))+
  
  geom_point(aes(color=Sample), alpha=0.8, position = position_dodge(0.75), size=3) + facet_grid(.~Coort, scales="free")




p+ geom_hline(yintercept = 0, linetype="dashed")

p <- ggplot(ddCq.data, aes(x=Target.tar, y=fold.ddCq,group= Target.tar))   + 
geom_boxplot(alpha=0.4, aes(fill=Target.tar))+
  
  geom_point(aes(color=Sample), alpha=0.8, position = position_dodge(0.75), size=3) + facet_grid(.~Coort, scales="free")




p + geom_hline(yintercept = 1, linetype="dashed")



```


## Statistics


Similarly, we will perform an ANOVA, plus a one-sample t-test to test if our changes are different from 0.

```{r}


mod <- aov(-ddCq ~ Coort*Target.tar, ddCq.data)

summary(mod)

emmeans(mod, pairwise ~ Target.tar | Coort)
## Does it make sense to compare miR129 to miR218? not really, but depending on your experimental setup, this could make sense.

mod <- aov(fold.ddCq ~ Coort*Target.tar, ddCq.data)

summary(mod)

emmeans(mod, pairwise ~ Target.tar | Coort)
## Completely different results if we use fold-change values! Be aware of that.




##One sample T-test
library(dplyr)
library(rstatix)


ddCq.data$ddCq <- -1 * ddCq.data$ddCq
paired.TTest <- ddCq.data %>% group_by(Coort, Target.tar) %>% t_test(ddCq ~ 1, mu=0)

## we need to adjust the p-values for multiple testing
paired.TTest$p.adjusted <- p.adjust(paired.TTest$p, method = "hochberg")
paired.TTest

## Lost significance after multiple correction


## How does the fold-change look like
paired.TTest <- ddCq.data %>% group_by(Coort, Target.tar) %>% t_test(fold.ddCq ~ 1, mu=1)

## we need to adjust the p-values for multiple testing
paired.TTest$p.adjusted <- p.adjust(paired.TTest$p, method = "hochberg")
paired.TTest

## A little better, we got significance for the miR129 condition



```




